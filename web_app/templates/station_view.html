{% extends "base.html" %}
{% block title %}{{ name }}{% endblock %}
{% block head %}
    {{ super() }}
    <link rel="stylesheet" href="{{ url_for('static', filename='style/map.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='style/scrollbar.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='style/station_view.css') }}">
{% endblock %}
{% block content %}
    <div class="wrapper">
        <div class="w3-container w3-blue-grey head">
            <h1>{{ name }} lat: {{ lat }} lon: {{ lng }}</h1>
        </div>
        <div class="w3-container w3-teal head_in">
            <h1>Input</h1>
        </div>
        <div class="w3-container w3-blue-grey head_out">
            <h1>Output</h1>
        </div>


        <div class="map">
            <svg id="svg_map" width="100%" height="100%"></svg>
        </div>

        <div class="input">
            <div class="scroll">
                <div class="w3-card-4 data_input">
                    <header class="w3-container w3-teal collapsible">
                        <h2>Data</h2>
                    </header>
                    <div class="w3-container w3-white content">
                        {% for segment in file_ns %}
                            <p>
                                <input class="w3-check data_tickbox" type="checkbox">
                                <label>{{ segment }}</label>
                            <p></p>
                            <ul class="key_list">
                                {% for k in keys[loop.index - 1] %}
                                    <li>{{ k }}</li>
                                {% endfor %}
                            </ul>
                            <hr>
                        {% endfor %}
                        <P></P>
                        <input class="w3-button w3-teal" id="load_data_button" type="button" value="Load">
                        <p></p>
                    </div>
                </div>

                <P></P>
                <div class="w3-card-4">
                    <header class="w3-container w3-blue-grey ">
                        <h2>Process stack</h2>
                    </header>
                    <div id="stack_list">
                        <ul class="w3-ul w3-border w3-white list"></ul>
                    </div>
                </div>
                <p></p>

                <input class="w3-button w3-blue-grey" id="calculate" type="button" value="Calculate">
                <hr>
                <p></p>
                <div class="w3-card-4">
                    <header class="w3-container w3-teal collapsible">
                        <h2>Sector</h2>
                    </header>
                    <div class="w3-container w3-white content">
                        <P>
                            <label>Start angle</label>
                            <input class="w3-input" id="start_angle_val" type="number" min="-360" max="360" value=150>
                        <P>
                            <label>End angle</label>
                            <input class="w3-input" id="end_angle_val" type="number" value=270>
                        <P>
                            <label id="distance_label">Distance: 10,000km</label>
                            <input class="w3-input" id="sec_dist_val" type="range" min="0" max="20000" value=10000
                                   oninput="updateRangeSlider(this.value);" onchange="updateRangeSlider(this.value);">
                        <P>
                            <label>Threshold (time outside sector)</label>
                            <input class="w3-input" id="sec_threshold_val" type="number" value=5>
                        <P>
                            <input class="w3-button w3-teal" id="add_sector" type="button" value="Add">
                    </div>

                </div>

                <p></p>
                <div class="w3-card-4">
                    <header class="w3-container w3-teal  collapsible">
                        <div class="w3-row-padding">
                            <div class="w3-half">
                                <h2>Filter</h2>
                            </div>
                        </div>
                    </header>
                    <div class="w3-container w3-white content">
                        <P></P>
                        <select id="filter_option" class="w3-select" name="option">
                            <option value="height">Height</option>
                            <option value="pressure">Pressure</option>
                        </select>
                        <P></P>
                        <label>Min</label>
                        <input class="w3-input" id="filter_min_val" type="number" value=0>
                        <P></P>
                        <label>Max</label>
                        <input class="w3-input" id="filter_max_val" type="number" value=0>
                        <P></P>
                        <label>Threshold</label>
                        <input class="w3-input" id="filter_thresh_val" type="number" value=0>
                        <P></P>
                        <input class="w3-button w3-teal" id="add_filter" type="button" value="Add">
                        <P></P>
                    </div>

                </div>
                <p></p>
                <div class="w3-card-4" id="cluster_div">
                    <header class="w3-container w3-teal collapsible">
                        <div class="w3-row-padding">
                            <div class="w3-half">
                                <h2>Cluster</h2>
                            </div>
                        </div>
                    </header>
                    <div id="cluster_container" class="w3-container w3-white content">
                        <P></P>
                        <label>Clustering method</label>
                        <select id="cluster_option" class="w3-select" name="cluster_select" selected="kmeans"
                                onchange='chooseClusterType()'>
                            <option value="kmeans">KMeans</option>
                            <option value="dbscan">DBSCAN</option>
                            <option value="dbscan_kmeans">DBSCAN and KMeans</option>
                        </select>
                        <P>
                        <div id="cluster_inputs">
                            <label>Cluster number</label>
                            <input class="w3-input" id="input_k" type="text">
                        </div>
                        <P>
                            <input class="w3-button w3-teal" id="add_cluster" type="button" value="Add">
                        <P></P>
                    </div>
                </div>
            </div>
        </div>


        <div class="output">
            <div class="scroll">
                <a id="export_data_button" class="w3-button w3-teal">Export Output</a>
                {#                <canvas id="OutputCanvas"></canvas>#}
{#                <img src="/test_figure">#}
                <div id="my_dataviz"></div>
            </div>
        </div>

    </div>
    <script src="{{ url_for('static', filename='javascript/station_utils.js') }}"></script>
    <script src="{{ url_for('static', filename='javascript/station_view_input.js') }}"></script>
    {#    <script src="{{ url_for('static', filename='javascript/station_view_output.js') }}"></script>#}
    <script src="{{ url_for('static', filename='javascript/data_utils.js') }}"></script>
    <script src="{{ url_for('static', filename='javascript/stack.js') }}"></script>
    <script>
        // 2. Use the margin convention practice
        var margin = {top: 50, right: 50, bottom: 50, left: 50}
            , width = 300 - margin.left - margin.right // Use the window's width
            , height = 250 - margin.top - margin.bottom; // Use the window's height

        // The number of datapoints
        var n = 40;

        // 5. X scale will use the index of our data
        var xScale = d3.scaleLinear()
            .domain([0, n - 1]) // input
            .range([0, width]); // output

        // 6. Y scale will use the randomly generate number
        var yScale = d3.scaleLinear()
            .domain([0, 1]) // input
            .range([height, 0]); // output

        // 7. d3's line generator
        var line = d3.line()
            .x(function (d, i) {
                return xScale(i);
            }) // set the x values for the line generator
            .y(function (d) {
                return yScale(d.y);
            }) // set the y values for the line generator
            .curve(d3.curveMonotoneX) // apply smoothing to the line

        // 8. An array of objects of length N. Each object has key -> value pair, the key being "y" and the value is a random number
        var dataset = d3.range(n).map(function (d) {
            return {"y": d3.randomUniform(1)()}
        })

        // 1. Add the SVG to the page and employ #2
        var svg2 = d3.select("#my_dataviz").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .attr("class", "graph-svg-component");

        // 3. Call the x axis in a group tag
        svg2.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(xScale)); // Create an axis component with d3.axisBottom

        // 4. Call the y axis in a group tag
        svg2.append("g")
            .attr("class", "y axis")
            .call(d3.axisLeft(yScale)); // Create an axis component with d3.axisLeft

        // 9. Append the path, bind the data, and call the line generator
        svg2.append("path")
            .datum(dataset) // 10. Binds data to the line
            .attr("class", "line") // Assign a class for styling
            .attr("d", line); // 11. Calls the line generator

        // 12. Appends a circle for each datapoint
        svg2.selectAll(".dot")
            .data(dataset)
            .enter().append("circle") // Uses the enter().append() method
            .attr("class", "dot") // Assign a class for styling
            .attr("cx", function (d, i) {
                return xScale(i)
            })
            .attr("cy", function (d) {
                return yScale(d.y)
            })
            .attr("r", 3)
            .on("mouseover", function (a, b, c) {
                console.log(a)
                this.attr('class', 'focus')
            })
            .on("mouseout", function () {
            });

        let coll = document.getElementsByClassName("collapsible");
        let i;
        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function () {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = content.scrollHeight + "px";
                }
            });
        }


        // Id of the stations
        let iid = "{{ id }}";
        let file_ns = {{ file_ns|tojson }};
        let proc_stack = new process_stack.stack();
        let lat = {{ lat }};
        let lon = {{ lon }};


        let trans = [0, 0, 1];

        const projection = d3.geoAzimuthalEquidistant().rotate([-lon, -lat]);
        const path = d3.geoPath().projection(projection);
        const zoom = d3.zoom().scaleExtent([1, 9]).on('zoom', zoomed);

        const svg = d3.select('#svg_map');
        let w = parseInt(svg.style("width"));
        let h = parseInt(svg.style("height"));
        const div = d3.select(".map");
        {#const canvasLayer = div.append('canvas').attr('id', 'heatmap').attr('width', w).attr('height', h);#}
        {#let canvas = canvasLayer.node(),#}
        {#    context = canvas.getContext("2d");#}
        const g = svg.append('g').call(d3.zoom().on("zoom", function () {
            svg.attr("transform", d3.event.transform)
        }));

        svg.style("width", "100%");
        g.call(zoom);

        renderMap(projection, path, lat, lon);


        function renderMap(proj, path, lat, lon) {
            d3.json("{{ url_for('static', filename='world-110m2.json') }}")
                .then(world => {
                    g.append('path')
                        .datum({type: 'Sphere'})
                        .attr('class', 'sphere')
                        .attr('d', path);

                    g.append('path')
                        .datum(topojson.merge(world, world.objects.countries.geometries))
                        .attr('class', 'land')
                        .attr('d', path);

                    g.append('path')
                        .datum(topojson.mesh(world, world.objects.countries, (a, b) => a !== b))
                        .attr('class', 'boundary')
                        .attr('d', path);
                    g.append("circle")
                        .attr("cx", proj([lon, lat])[0])
                        .attr("cy", proj([lon, lat])[1])
                        .attr("r", 2.5)
                        .style("fill", "white");
                });

        }

        let center_point = projection([lon, lat]);

        function renderSector(start, end, dist) {
            g.select(".arc").remove();
            var arc = d3.arc()
                .innerRadius(0)
                .outerRadius(dist)
                .startAngle(start * (Math.PI / 180))
                .endAngle(end * (Math.PI / 180));
            g.append("path")
                .attr("class", "arc")
                .attr("d", arc)
                .attr("transform", "translate(" + center_point[0] * trans[2] + "," + center_point[1] * trans[2] + ")" + "translate(" + trans[0] + "," + trans[1] + ")" + "scale(" + trans[2] + ")")
                .attr("fill-opacity", "0.3")
                .style("fill", "#8b0000");
        }


        let lineFunction = d3.line()
            .x(function (d) {
                return projection([d[1], d[0]])[0];
            })
            .y(function (d) {
                return projection([d[1], d[0]])[1];
            });


        function renderLines(mm, weight, colours) {
            g.selectAll(".traj").remove();
            let lat_lng = [mm["lat"], mm["lon"]];
            let p = [];

            // for each cluster
            for (let l = 0; l < lat_lng[0].length; l++) {
                p_ = [];
                lats = lat_lng[0][l];
                longs = lat_lng[1][l];

                // for each traj in that cluster
                for (let i = 0; i < lats.length; i++) {
                    p_.push([lats[i], longs[i]]);
                }
                p.push(p_);
            }

            let m = Math.max(...weight);
            for (let i = 0; i < lat_lng[0].length; i++) {
                let w = weight[i];
                let hsl_string = "".concat("hsl(", colours[i], ", 50%, 50%)");
                g.append("path")
                    .attr("class", "traj")
                    .attr("d", lineFunction(p[i]))
                    .attr("stroke", hsl_string)
                    .attr("opacity", 0.7)
                    .attr("stroke-width", (w / m) * 2.5)
                    .attr("fill", "none")
                    .attr("transform", "translate(" + trans[0] + "," + trans[1] + ")" + "scale(" + trans[2] + ")");
            }
        }

        function render_all_lines(mm, parse = false) {
            if (parse) {
                mm = JSON.parse(mm);
            }

            g.selectAll(".traj").remove();
            let lat_lng = [mm["lat"], mm["lon"]];

            let p = [];
            for (let l = 0; l < lat_lng[0].length; l += 1) {
                p_ = [];
                lats = lat_lng[0][l];
                longs = lat_lng[1][l];

                for (let i = 0; i < lats.length; i += 1) {
                    p_.push([lats[i], longs[i]]);
                }
                p.push(p_);
            }
            // let m = Math.max(...weight);
            for (let i = 0; i < lat_lng[0].length; i++) {
                // let w = weight[i];
                g.append("path")
                    .attr("class", "traj")
                    .attr("d", lineFunction(p[i]))

                    .attr("stroke", function () {
                        return "gray";
                    }).attr("id", i)
                    .attr("stroke-width", 0.5)
                    .attr("fill", "none")
                    .attr("opacity", 0.2)
                    .attr("transform", "translate(" + trans[0] + "," + trans[1] + ")" + "scale(" + trans[2] + ")");
            }

        }


        function zoomed() {
            trans = [d3.event.transform.x, d3.event.transform.y, d3.event.transform.k];
            g.selectAll('path')
                .attr('transform', d3.event.transform);
            g.selectAll('circle')
                .attr('transform', d3.event.transform);
            g.selectAll('.arc').attr("transform", "translate(" + center_point[0] * d3.event.transform.k + "," + center_point[1] * d3.event.transform.k + ")" + d3.event.transform);
        }


    </script>
{% endblock %}